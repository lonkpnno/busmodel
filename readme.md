# 统一解决并发问题，提高系统可靠性和可用性

### 公式
        用统一的公式一次性解决防抖、并发锁、限流等问题
        用户id:api请求路径:最大并发线程数:超时时间
        bus:
            userRuleList:
                -   apiUrl: "/api1"
                    concurrency: 1
                    timeout: 100
            globalRuleList:
                -   apiUrl: "/api2"
                    concurrency: 2
                    timeout: 10
* 普通模式

        单机版的sentinel
* 分布式模式
        
        key: {用户id;api请求路径}机器id
        value: 已发行的通行证
        使用lua脚本进行统计
        使用完释放通行证
        参考redisson的看门狗对可行证进行续期
        （unlock失败，定时重试释放通行证）
        
* 响应式模式

        用户id:api请求路径:最大并发线程数（21以下用线程池来做）:同时最大任务数（正在处理+等待）

        用户id:api请求路径下，最大并发数个虚拟线程+一个阻塞队列
        全局N个线程池+N个阻塞队列（会出现线程不负载，而任务却要排队的情况，任务分配不均）
        eg:
        线程组：线程1、线程2、线程3、线程4、线程5
        api: api队列1、api队列2
        线程1、线程2、线程3负责第一个队列
        线程3、线程4、线程5负责第二个队列
        第一个队列的线程3可能忙于处理第二个队列任务，而线程4、线程5没有任务处理

        接收请求
        对应接口任务数是否大于等于同时最大任务数
        大于等于则直接返回
        对应接口任务数原子地+1
        看哪个队列元素少就往哪个队列里加任务
        处理完任务将对应接口任务数原子地-1
